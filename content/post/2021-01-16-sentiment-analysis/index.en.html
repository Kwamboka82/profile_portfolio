<link href="index.en_files/anchor-sections/anchor-sections.css" rel="stylesheet" />
<script src="index.en_files/anchor-sections/anchor-sections.js"></script>


<p><strong>Data set</strong>: <a href="https://github.com/rfordatascience/tidytuesday/blob/master/data/2020/2020-05-05/readme.md">Animal Crossing user reviews from #TidyTuesday dataset</a></p>
<p><strong>Task</strong>: Sentimental Analysis - Using the text from User reviews predict user ratings.</p>
<p><strong>Expected results</strong>: To check how positive or negative the user review is based on their comments.</p>
<p></br></p>
<p>Here is the code I used in the video, for those who prefer reading instead of or in addition to video.</p>
<div id="explore-the-data" class="section level2">
<h2>Explore the data</h2>
<p>Our modeling goal is to predict the rating for <a href="https://github.com/rfordatascience/tidytuesday/blob/master/data/2020/2020-05-05/readme.md">Animal Crossing user reviews from this week’s #TidyTuesday dataset</a> from the text in the review. This is what is typically called a sentiment analysis model, and it’s a common real-world problem! Let’s get started by looking at the user review data.</p>
<pre class="r"><code>library(tidyverse)

user_reviews &lt;- readr::read_tsv(&#39;https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2020/2020-05-05/user_reviews.tsv&#39;)

user_reviews %&gt;%
  count(grade) %&gt;%
  ggplot(aes(grade, n)) +
  geom_col(fill = &quot;midnightblue&quot;, alpha = 0.7)</code></pre>
<p><img src="index.en_files/figure-html/unnamed-chunk-2-1.png" width="2400" /></p>
<p>Lots of people give scores of zero, and lots of people give scores of 10. This does not look like a nice distribution for predicting a not-even-really-continuous quantity like this <code>grade</code>, so we’ll convert these user scores to a label, good vs. bad user reviews, and build a classification model.</p>
<pre class="r"><code>## not run here
user_reviews %&gt;% 
  filter(grade &gt; 8) %&gt;% 
  sample_n(5) %&gt;% 
  pull(text)</code></pre>
<p>We definitely saw some evidence of scraping problems when looking at the review text. We will remove at least the final <code>"Expand"</code> from the reviews, and create a new categorical <code>rating</code> variable.</p>
<pre class="r"><code>reviews_parsed &lt;- user_reviews %&gt;%
  mutate(text = str_remove(text, &quot;Expand$&quot;)) %&gt;%
  mutate(rating = case_when(grade &gt; 7 ~ &quot;good&quot;,
                            TRUE ~ &quot;bad&quot;))</code></pre>
<p>What is the distribution of words per review?</p>
<pre class="r"><code>library(tidytext)

words_per_review &lt;- reviews_parsed %&gt;%
  unnest_tokens(word, text) %&gt;%
  count(user_name, name = &quot;total_words&quot;)

words_per_review %&gt;%
  ggplot(aes(total_words)) +
  geom_histogram(fill = &quot;midnightblue&quot;, alpha = 0.8)</code></pre>
<p><img src="index.en_files/figure-html/unnamed-chunk-5-1.png" width="2400" /></p>
<p>I don’t believe this can be a true, natural distribution of words per review. That sharp drop in the distribution looks very strange and I believe is a sign of some problem with the data generation process (i.e. a scraping problem). That’s life sometimes! Data is never perfect and sometimes we have to do the best we can with the data available. If this was my own project from start-to-finish, I would go back to the scraping and see if I could make any improvements at that stage.</p>
<p>For now, let’s forge ahead and see what we can learn. There are lots more great examples of #TidyTuesday EDA out there to explore, <a href="https://twitter.com/justynapawlata/status/1257718507002826752">including more text mining</a>!</p>
</div>
<div id="build-a-model" class="section level2">
<h2>Build a model</h2>
<p>We start by loading the tidymodels metapackage, that helps us in splitting our data into training and testing sets.</p>
<pre class="r"><code>library(tidymodels)

set.seed(123)
review_split &lt;- initial_split(reviews_parsed, strata = rating)
review_train &lt;- training(review_split)
review_test &lt;- testing(review_split)</code></pre>
<p>Next, let’s <strong>preprocess</strong> our data to get it ready for modeling. We can use specialized steps from <a href="https://tidymodels.github.io/textrecipes/">textrecipes</a>, along with the general recipe steps.</p>
<pre class="r"><code>library(textrecipes)
library(stopwords)

review_rec &lt;- recipe(rating ~ text, data = review_train) %&gt;%
  step_tokenize(text) %&gt;%
  textrecipes::step_stopwords(text) %&gt;%
  step_tokenfilter(text, max_tokens = 500) %&gt;%
  step_tfidf(text) %&gt;%
  step_normalize(all_predictors())

review_prep &lt;- prep(review_rec)

review_prep</code></pre>
<pre><code>## Data Recipe
## 
## Inputs:
## 
##       role #variables
##    outcome          1
##  predictor          1
## 
## Training data contained 2250 data points and no missing data.
## 
## Operations:
## 
## Tokenization for text [trained]
## Stop word removal for text [trained]
## Text filtering for text [trained]
## Term frequency-inverse document frequency with text [trained]
## Centering and scaling for tfidf_text_0, tfidf_text_1, ... [trained]</code></pre>
<p>Let’s walk through the steps in this recipe, which are what I consider sensible defaults for a first attempt at training a text classification model such as a sentiment analysis model.</p>
<ul>
<li>First, we must tell the <code>recipe()</code> what our model is going to be (using a formula here) and what data we are using.</li>
<li>Next, we tokenize our text, with the default tokenization into single words.</li>
<li>Next, we remove stop words (again, just the default set).</li>
<li>It wouldn’t be practical to keep all the tokens from this whole dataset in our model, so we can filter down to only keep, in this case, the top 500 most-used tokens (after removing stop words). This is a pretty dramatic cut and keeping more tokens would be a good next step in improving this model.</li>
<li>We need to decide on some kind of weighting for these tokens next, either something like term frequency or, what we used here, <a href="https://www.tidytextmining.com/tfidf.html">tf-idf</a>.</li>
<li>Finally, we center and scale (i.e. normalize) all the newly created tf-idf values because the model we are going to use is sensitive to this.</li>
</ul>
<p>Before using <code>prep()</code> these steps have been defined but not actually run or implemented. The <code>prep()</code> function is where everything gets evaluated.</p>
<p>Now it’s time to <strong>specify</strong> our model. Here we can set up the model specification for lasso regression with <code>penalty = tune()</code> since we don’t yet know the best value for the regularization parameter and <code>mixture = 1</code> for lasso. In my experience, the lasso has proved to be a good baseline for text modeling. (And sometimes it is hard to do much better!)</p>
<p>I am using a <a href="https://tidymodels.github.io/workflows/"><code>workflow()</code></a> in this example for convenience; these are objects that can help you manage modeling pipelines more easily, with pieces that fit together like Lego blocks. This <code>workflow()</code> contains both the recipe and the model.</p>
<pre class="r"><code>lasso_spec &lt;- logistic_reg(penalty = tune(), mixture = 1) %&gt;%
  set_engine(&quot;glmnet&quot;)

lasso_wf &lt;- workflow() %&gt;%
  add_recipe(review_rec) %&gt;%
  add_model(lasso_spec)

lasso_wf</code></pre>
<pre><code>## == Workflow ====================================================================
## Preprocessor: Recipe
## Model: logistic_reg()
## 
## -- Preprocessor ----------------------------------------------------------------
## 5 Recipe Steps
## 
## * step_tokenize()
## * step_stopwords()
## * step_tokenfilter()
## * step_tfidf()
## * step_normalize()
## 
## -- Model -----------------------------------------------------------------------
## Logistic Regression Model Specification (classification)
## 
## Main Arguments:
##   penalty = tune()
##   mixture = 1
## 
## Computational engine: glmnet</code></pre>
</div>
<div id="tune-model-parameters" class="section level2">
<h2>Tune model parameters</h2>
<p>Let’s get ready to <a href="https://www.tidymodels.org/start/tuning/">tune</a> the lasso model! First, we need a set of possible regularization parameters to try.</p>
<pre class="r"><code>lambda_grid &lt;- grid_regular(penalty(), levels = 40)</code></pre>
<p>Next, we need a set of resampled data to fit and evaluate all these models.</p>
<pre class="r"><code>set.seed(123)
review_folds &lt;- bootstraps(review_train, strata = rating)
review_folds</code></pre>
<pre><code>## # Bootstrap sampling using stratification 
## # A tibble: 25 x 2
##    splits             id         
##    &lt;list&gt;             &lt;chr&gt;      
##  1 &lt;split [2.2K/812]&gt; Bootstrap01
##  2 &lt;split [2.2K/850]&gt; Bootstrap02
##  3 &lt;split [2.2K/814]&gt; Bootstrap03
##  4 &lt;split [2.2K/814]&gt; Bootstrap04
##  5 &lt;split [2.2K/853]&gt; Bootstrap05
##  6 &lt;split [2.2K/840]&gt; Bootstrap06
##  7 &lt;split [2.2K/816]&gt; Bootstrap07
##  8 &lt;split [2.2K/826]&gt; Bootstrap08
##  9 &lt;split [2.2K/804]&gt; Bootstrap09
## 10 &lt;split [2.2K/809]&gt; Bootstrap10
## # ... with 15 more rows</code></pre>
<p>Now we can put it all together and implement the tuning. We can set specific metrics to compute during tuning with <code>metric_set()</code>. Let’s look at AUC, positive predictive value, and negative predictive value so we can understand if one class is harder to predict than another.</p>
<pre class="r"><code>doParallel::registerDoParallel()

set.seed(2020)
lasso_grid &lt;- tune_grid(
  lasso_wf,
  resamples = review_folds,
  grid = lambda_grid,
  metrics = metric_set(roc_auc, ppv, npv)
)</code></pre>
<p>Once we have our tuning results, we can examine them in detail.</p>
<pre class="r"><code>lasso_grid %&gt;%
  collect_metrics()</code></pre>
<pre><code>## # A tibble: 120 x 7
##     penalty .metric .estimator  mean     n std_err .config              
##       &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt;   &lt;dbl&gt; &lt;chr&gt;                
##  1 1.00e-10 npv     binary     0.740    25 0.00518 Preprocessor1_Model01
##  2 1.00e-10 ppv     binary     0.864    25 0.00302 Preprocessor1_Model01
##  3 1.00e-10 roc_auc binary     0.878    25 0.00276 Preprocessor1_Model01
##  4 1.80e-10 npv     binary     0.740    25 0.00518 Preprocessor1_Model02
##  5 1.80e-10 ppv     binary     0.864    25 0.00302 Preprocessor1_Model02
##  6 1.80e-10 roc_auc binary     0.878    25 0.00276 Preprocessor1_Model02
##  7 3.26e-10 npv     binary     0.740    25 0.00518 Preprocessor1_Model03
##  8 3.26e-10 ppv     binary     0.864    25 0.00302 Preprocessor1_Model03
##  9 3.26e-10 roc_auc binary     0.878    25 0.00276 Preprocessor1_Model03
## 10 5.88e-10 npv     binary     0.740    25 0.00518 Preprocessor1_Model04
## # ... with 110 more rows</code></pre>
<p>Visualization is often more helpful to understand model performance.</p>
<pre class="r"><code>lasso_grid %&gt;%
  collect_metrics() %&gt;%
  ggplot(aes(penalty, mean, color = .metric)) +
  geom_line(size = 1.5, show.legend = FALSE) +
  facet_wrap(~.metric) +
  scale_x_log10()</code></pre>
<p><img src="index.en_files/figure-html/unnamed-chunk-13-1.png" width="3000" /></p>
<p>This shows us a lot. We see clearly that AUC and PPV have benefited from the regularization and we could identify the best value of <code>penalty</code> for each of those metrics. The same is not true for NPV. One class (the happy comments) is harder to predict than the other. It might be worth including more tokens in our model, based on this plot.</p>
</div>
<div id="choose-the-final-model" class="section level2">
<h2>Choose the final model</h2>
<p>Let’s keep our model as is for now, and choose a final model based on AUC. We can use <code>select_best()</code> to find the best AUC and then update our workflow <code>lasso_wf</code> with this value.</p>
<pre class="r"><code>best_auc &lt;- lasso_grid %&gt;%
  select_best(&quot;roc_auc&quot;)

best_auc</code></pre>
<pre><code>## # A tibble: 1 x 2
##   penalty .config              
##     &lt;dbl&gt; &lt;chr&gt;                
## 1 0.00889 Preprocessor1_Model32</code></pre>
<pre class="r"><code>final_lasso &lt;- finalize_workflow(lasso_wf, best_auc)

final_lasso</code></pre>
<pre><code>## == Workflow ====================================================================
## Preprocessor: Recipe
## Model: logistic_reg()
## 
## -- Preprocessor ----------------------------------------------------------------
## 5 Recipe Steps
## 
## * step_tokenize()
## * step_stopwords()
## * step_tokenfilter()
## * step_tfidf()
## * step_normalize()
## 
## -- Model -----------------------------------------------------------------------
## Logistic Regression Model Specification (classification)
## 
## Main Arguments:
##   penalty = 0.00888623816274339
##   mixture = 1
## 
## Computational engine: glmnet</code></pre>
<p>This is our tuned, finalized workflow (but it is not fit yet). One of the things we can do when we start to fit this finalized workflow on the whole training set is to see what the most important variables are using the <a href="https://koalaverse.github.io/vip/">vip</a> package.</p>
<pre class="r"><code>library(vip)

final_lasso %&gt;%
  fit(review_train) %&gt;%
  pull_workflow_fit() %&gt;%
  vi(lambda = best_auc$penalty) %&gt;%
  group_by(Sign) %&gt;%
  top_n(20, wt = abs(Importance)) %&gt;%
  ungroup() %&gt;%
  mutate(Importance = abs(Importance),
         Variable = str_remove(Variable, &quot;tfidf_text_&quot;),
         Variable = fct_reorder(Variable, Importance)) %&gt;%
  ggplot(aes(x = Importance, y = Variable, fill = Sign)) +
  geom_col(show.legend = FALSE) +
  facet_wrap(~Sign, scales = &quot;free_y&quot;) +
  labs(y = NULL)</code></pre>
<p><img src="index.en_files/figure-html/unnamed-chunk-15-1.png" width="2400" /></p>
<p>People who are happy with Animal Crossing like to talk about how relaxing, fantastic, enjoyable, and great it is, and also talk in their reviews about the “review bombing” of the negative reviews. Notice that many of the words from the negative reviews are specifically used to talk about the multiplayer experience (it’s boring for the second player, second player cannot do “anything” or move the story forward, cooperative/coop play doesn’t work well, etc). These users want a fix and they declare Nintendo greedy for the one-island-per-console play.</p>
<p>Finally, let’s return to our test data. The tune package has a function <code>last_fit()</code> which is nice for situations when you have tuned and finalized a model or workflow and want to fit it one last time on your training data and evaluate it on your testing data. You only have to pass this function your finalized model/workflow and your split.</p>
<pre class="r"><code>review_final &lt;- last_fit(final_lasso, review_split)

review_final %&gt;%
  collect_metrics()</code></pre>
<pre><code>## # A tibble: 2 x 4
##   .metric  .estimator .estimate .config             
##   &lt;chr&gt;    &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;               
## 1 accuracy binary         0.892 Preprocessor1_Model1
## 2 roc_auc  binary         0.941 Preprocessor1_Model1</code></pre>
<p>We did not overfit during our tuning process, and the overall accuracy is not bad. Let’s create a confusion matrix for the testing data.</p>
<pre class="r"><code>review_final %&gt;%
  collect_predictions() %&gt;%
  conf_mat(rating, .pred_class)</code></pre>
<pre><code>##           Truth
## Prediction bad good
##       bad  449   55
##       good  26  219</code></pre>
<p>Although our overall accuracy isn’t so bad, we find that it is easier to detect the negative reviews than the positive ones.</p>
</div>
